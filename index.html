<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>aespa TETRIS</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback } = React;

        const Play = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <polygon points="5 3 19 12 5 21 5 3"></polygon>
            </svg>
        );

        const RotateCw = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <polyline points="23 4 23 10 17 10"></polyline>
                <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
            </svg>
        );

        const VolumeIcon = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
                <path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path>
            </svg>
        );

        const VolumeMuteIcon = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
                <line x1="23" y1="9" x2="17" y2="15"></line>
                <line x1="17" y1="9" x2="23" y2="15"></line>
            </svg>
        );

        const PauseIcon = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <rect x="6" y="4" width="4" height="16"></rect>
                <rect x="14" y="4" width="4" height="16"></rect>
            </svg>
        );

        const PlayIconSmall = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <polygon points="5 3 19 12 5 21 5 3"></polygon>
            </svg>
        );

        const TrophyIcon = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"></path>
                <path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"></path>
                <path d="M4 22h16"></path>
                <path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"></path>
                <path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"></path>
                <path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"></path>
            </svg>
        );

        const BOARD_WIDTH = 10;
        const BOARD_HEIGHT = 20;
        const BLOCK_SIZE = 30;

        const AESPA_MEMBERS = [
          { 
            name: 'KARINA', 
            color: 'bg-pink-500', 
            border: 'border-pink-600',
            images: [
              './images/karina1.jpg',
              './images/karina2.jpg',
              './images/karina3.jpg',
              './images/karina4.jpg',
              './images/karina5.jpg',
              './images/karina6.jpg'
            ]
          },
          { 
            name: 'GISELLE', 
            color: 'bg-purple-500', 
            border: 'border-purple-600',
            images: [
              './images/giselle1.jpg',
              './images/giselle2.jpg',
              './images/giselle3.jpg',
              './images/giselle4.jpg',
              './images/giselle5.jpg',
              './images/giselle6.jpg'
            ]
          },
          { 
            name: 'WINTER', 
            color: 'bg-blue-500', 
            border: 'border-blue-600',
            images: [
              './images/winter1.jpg',
              './images/winter2.jpg',
              './images/winter3.jpg',
              './images/winter4.jpg',
              './images/winter5.jpg',
              './images/winter6.jpg'
            ]
          },
          { 
            name: 'NINGNING', 
            color: 'bg-yellow-400', 
            border: 'border-yellow-500',
            images: [
              './images/ning1.jpg',
              './images/ning2.jpg',
              './images/ning3.jpg',
              './images/ning4.jpg',
              './images/ning5.jpg',
              './images/ning6.jpg'
            ]
          }
        ];

        const SHAPES = [
          [[1, 1, 1, 1]], // I
          [[1, 1], [1, 1]], // O
          [[0, 1, 0], [1, 1, 1]], // T
          [[1, 0, 0], [1, 1, 1]], // L
          [[0, 0, 1], [1, 1, 1]], // J
          [[0, 1, 1], [1, 1, 0]], // S
          [[1, 1, 0], [0, 1, 1]] // Z
        ];

        const AespaTetris = () => {
          const [board, setBoard] = useState([]);
          const [currentPiece, setCurrentPiece] = useState(null);
          const [position, setPosition] = useState({ x: 0, y: 0 });
          const [score, setScore] = useState(0);
          const [gameOver, setGameOver] = useState(false);
          const [gameStarted, setGameStarted] = useState(false);
          const [level, setLevel] = useState(1);
          const [touchStart, setTouchStart] = useState(null);
          const [touchEnd, setTouchEnd] = useState(null);
          const [imagesLoaded, setImagesLoaded] = useState({});
          const [allImagesPreloaded, setAllImagesPreloaded] = useState(false);
          const [isMuted, setIsMuted] = useState(false);
          const [isPaused, setIsPaused] = useState(false);
          const audioRef = React.useRef(null);
          const [leaderboard, setLeaderboard] = useState([]);
          const [showLeaderboard, setShowLeaderboard] = useState(false);
          const [showHighScoreEntry, setShowHighScoreEntry] = useState(false);
          const [playerName, setPlayerName] = useState('');
          const [finalGameScore, setFinalGameScore] = useState(0);

          useEffect(() => {
            const loadImages = async () => {
              const imageUrls = AESPA_MEMBERS.flatMap(member => member.images);
              const loadPromises = imageUrls.map(url => {
                return new Promise((resolve) => {
                  const img = new Image();
                  img.onload = () => {
                    setImagesLoaded(prev => ({ ...prev, [url]: true }));
                    resolve();
                  };
                  img.onerror = () => {
                    setImagesLoaded(prev => ({ ...prev, [url]: false }));
                    resolve();
                  };
                  img.src = url;
                });
              });
              
              await Promise.all(loadPromises);
              setAllImagesPreloaded(true);
            };

            loadImages();
            loadLeaderboard();

            audioRef.current = new Audio('./music/background.mp3');
            audioRef.current.loop = true;
            audioRef.current.volume = 0.3;

            return () => {
              if (audioRef.current) {
                audioRef.current.pause();
                audioRef.current = null;
              }
            };
          }, []);

          const loadLeaderboard = async () => {
            try {
              // Use localStorage for deployed version (personal scores only)
              const stored = localStorage.getItem('aespa-tetris-leaderboard');
              if (stored) {
                const scores = JSON.parse(stored);
                setLeaderboard(scores);
              }
            } catch (error) {
              console.log('No leaderboard data yet');
              setLeaderboard([]);
            }
          };

          const saveScoreToLeaderboard = async (name, finalScore) => {
            try {
              const newEntry = {
                name: name.trim() || 'Anonymous',
                score: finalScore,
                date: new Date().toISOString()
              };

              const updatedLeaderboard = [...leaderboard, newEntry]
                .sort((a, b) => b.score - a.score)
                .slice(0, 10);

              // Use localStorage for deployed version (personal scores only)
              localStorage.setItem('aespa-tetris-leaderboard', JSON.stringify(updatedLeaderboard));
              setLeaderboard(updatedLeaderboard);
              setShowHighScoreEntry(false);
              
              // Show leaderboard after saving
              setTimeout(() => {
                setShowLeaderboard(true);
              }, 300);
            } catch (error) {
              console.error('Failed to save score:', error);
              setShowHighScoreEntry(false);
            }
          };

          const isHighScore = (finalScore) => {
            if (leaderboard.length < 10) return true;
            return finalScore > leaderboard[leaderboard.length - 1].score;
          };

          useEffect(() => {
            if (!audioRef.current) return;

            if (gameStarted && !gameOver && !isMuted && !isPaused) {
              audioRef.current.play().catch(err => {
                console.log('Audio play failed:', err);
              });
            } else {
              audioRef.current.pause();
            }
          }, [gameStarted, gameOver, isMuted, isPaused]);

          const toggleMute = () => {
            setIsMuted(!isMuted);
            if (audioRef.current) {
              if (!isMuted) {
                audioRef.current.pause();
              } else if (gameStarted && !gameOver && !isPaused) {
                audioRef.current.play().catch(err => console.log('Audio play failed:', err));
              }
            }
          };

          const togglePause = () => {
            if (!gameStarted || gameOver) return;
            setIsPaused(!isPaused);
          };

          const createEmptyBoard = () => {
            return Array(BOARD_HEIGHT).fill(null).map(() => Array(BOARD_WIDTH).fill(null));
          };

          const createNewPiece = () => {
            const shape = SHAPES[Math.floor(Math.random() * SHAPES.length)];
            const memberTemplate = AESPA_MEMBERS[Math.floor(Math.random() * AESPA_MEMBERS.length)];
            const randomImage = memberTemplate.images[Math.floor(Math.random() * memberTemplate.images.length)];
            
            const member = {
              name: memberTemplate.name,
              color: memberTemplate.color,
              border: memberTemplate.border,
              image: randomImage
            };
            
            return { shape, member };
          };

          const initGame = () => {
            setBoard(createEmptyBoard());
            setCurrentPiece(createNewPiece());
            setPosition({ x: Math.floor(BOARD_WIDTH / 2) - 1, y: 0 });
            setScore(0);
            setLevel(1);
            setGameOver(false);
            setGameStarted(true);
            setIsPaused(false);
            setPlayerName('');
            setShowHighScoreEntry(false);
            setFinalGameScore(0);
            if (audioRef.current) {
              audioRef.current.currentTime = 0;
            }
          };

          const checkCollision = (piece, pos, boardState) => {
            for (let y = 0; y < piece.shape.length; y++) {
              for (let x = 0; x < piece.shape[y].length; x++) {
                if (piece.shape[y][x]) {
                  const newX = pos.x + x;
                  const newY = pos.y + y;
                  
                  if (newX < 0 || newX >= BOARD_WIDTH || newY >= BOARD_HEIGHT) {
                    return true;
                  }
                  
                  if (newY >= 0 && boardState[newY][newX]) {
                    return true;
                  }
                }
              }
            }
            return false;
          };

          const mergePieceToBoard = () => {
            const newBoard = board.map(row => [...row]);
            currentPiece.shape.forEach((row, y) => {
              row.forEach((cell, x) => {
                if (cell) {
                  const boardY = position.y + y;
                  const boardX = position.x + x;
                  if (boardY >= 0 && boardY < BOARD_HEIGHT && boardX >= 0 && boardX < BOARD_WIDTH) {
                    newBoard[boardY][boardX] = currentPiece.member;
                  }
                }
              });
            });
            return newBoard;
          };

          const clearLines = (boardState) => {
            let linesCleared = 0;
            const newBoard = boardState.filter(row => {
              if (row.every(cell => cell !== null)) {
                linesCleared++;
                return false;
              }
              return true;
            });
            
            while (newBoard.length < BOARD_HEIGHT) {
              newBoard.unshift(Array(BOARD_WIDTH).fill(null));
            }
            
            return { newBoard, linesCleared };
          };

          const moveDown = useCallback(() => {
            if (!currentPiece || gameOver || !gameStarted || isPaused) return;

            const newPos = { ...position, y: position.y + 1 };
            
            if (!checkCollision(currentPiece, newPos, board)) {
              setPosition(newPos);
            } else {
              const newBoard = mergePieceToBoard();
              const { newBoard: clearedBoard, linesCleared } = clearLines(newBoard);
              
              // Calculate final score
              const finalScore = score + (linesCleared * 100 * level);
              
              setBoard(clearedBoard);
              setScore(finalScore);
              setLevel(Math.floor(finalScore / 1000) + 1);
              
              const nextPiece = createNewPiece();
              const startPos = { x: Math.floor(BOARD_WIDTH / 2) - 1, y: 0 };
              
              if (checkCollision(nextPiece, startPos, clearedBoard)) {
                setGameOver(true);
                setGameStarted(false);
                setFinalGameScore(finalScore);
                // Always show name entry for all players
                setShowHighScoreEntry(true);
              } else {
                setCurrentPiece(nextPiece);
                setPosition(startPos);
              }
            }
          }, [currentPiece, position, board, gameOver, gameStarted, score, level, isPaused, leaderboard]);

          const moveLeft = () => {
            if (!currentPiece || gameOver || isPaused) return;
            const newPos = { ...position, x: position.x - 1 };
            if (!checkCollision(currentPiece, newPos, board)) {
              setPosition(newPos);
            }
          };

          const moveRight = () => {
            if (!currentPiece || gameOver || isPaused) return;
            const newPos = { ...position, x: position.x + 1 };
            if (!checkCollision(currentPiece, newPos, board)) {
              setPosition(newPos);
            }
          };

          const rotate = () => {
            if (!currentPiece || gameOver || isPaused) return;
            const rotated = currentPiece.shape[0].map((_, i) =>
              currentPiece.shape.map(row => row[i]).reverse()
            );
            const rotatedPiece = { ...currentPiece, shape: rotated };
            
            if (!checkCollision(rotatedPiece, position, board)) {
              setCurrentPiece(rotatedPiece);
            }
          };

          const minSwipeDistance = 50;

          const onTouchStart = (e) => {
            setTouchEnd(null);
            setTouchStart({
              x: e.targetTouches[0].clientX,
              y: e.targetTouches[0].clientY
            });
          };

          const onTouchMove = (e) => {
            setTouchEnd({
              x: e.targetTouches[0].clientX,
              y: e.targetTouches[0].clientY
            });
          };

          const onTouchEnd = () => {
            if (!touchStart || !touchEnd || !gameStarted || gameOver || isPaused) return;
            
            const distanceX = touchStart.x - touchEnd.x;
            const distanceY = touchStart.y - touchEnd.y;
            const isLeftSwipe = distanceX > minSwipeDistance;
            const isRightSwipe = distanceX < -minSwipeDistance;
            const isDownSwipe = distanceY < -minSwipeDistance;
            
            if (Math.abs(distanceX) > Math.abs(distanceY)) {
              if (isLeftSwipe) {
                moveLeft();
              } else if (isRightSwipe) {
                moveRight();
              }
            } else if (isDownSwipe) {
              moveDown();
            }
          };

          useEffect(() => {
            if (!gameStarted || gameOver) return;

            const handleKeyPress = (e) => {
              if (e.key === 'p' || e.key === 'P' || e.key === 'Escape') {
                e.preventDefault();
                togglePause();
                return;
              }
              
              if (isPaused) return;

              switch(e.key) {
                case 'ArrowLeft':
                  e.preventDefault();
                  moveLeft();
                  break;
                case 'ArrowRight':
                  e.preventDefault();
                  moveRight();
                  break;
                case 'ArrowDown':
                  e.preventDefault();
                  moveDown();
                  break;
                case 'ArrowUp':
                case ' ':
                  e.preventDefault();
                  rotate();
                  break;
              }
            };

            window.addEventListener('keydown', handleKeyPress);
            return () => window.removeEventListener('keydown', handleKeyPress);
          }, [gameStarted, gameOver, isPaused, moveDown]);

          useEffect(() => {
            if (!gameStarted || gameOver || isPaused) return;

            const speed = Math.max(200, 1000 - (level - 1) * 100);
            const timer = setInterval(moveDown, speed);
            return () => clearInterval(timer);
          }, [gameStarted, gameOver, isPaused, moveDown, level]);

          const renderCell = (cell) => {
            if (!cell) return <div className="w-full h-full border border-gray-700 bg-gray-900"></div>;
            
            const imageLoaded = imagesLoaded[cell.image];
            
            return (
              <div className={`w-full h-full border-2 ${cell.border} ${cell.color} overflow-hidden relative`}>
                {imageLoaded !== false ? (
                  <img 
                    src={cell.image} 
                    alt={cell.name}
                    className="w-full h-full object-cover"
                    onError={(e) => {
                      e.target.style.display = 'none';
                    }}
                  />
                ) : (
                  <span className="text-[8px] font-bold text-white absolute inset-0 flex items-center justify-center">{cell.name}</span>
                )}
              </div>
            );
          };

          const getDisplayBoard = () => {
            const displayBoard = board.map(row => [...row]);
            
            if (currentPiece) {
              currentPiece.shape.forEach((row, y) => {
                row.forEach((cell, x) => {
                  if (cell) {
                    const boardY = position.y + y;
                    const boardX = position.x + x;
                    if (boardY >= 0 && boardY < BOARD_HEIGHT && boardX >= 0 && boardX < BOARD_WIDTH) {
                      displayBoard[boardY][boardX] = currentPiece.member;
                    }
                  }
                });
              });
            }
            
            return displayBoard;
          };

          const handleRotateTouch = (e) => {
            e.preventDefault();
            e.stopPropagation();
            rotate();
          };

          const handleButtonTouch = (action) => (e) => {
            e.preventDefault();
            e.stopPropagation();
            action();
          };

          return (
            <div className="min-h-screen bg-gradient-to-br from-purple-900 via-pink-900 to-blue-900 flex items-center justify-center p-4">
              <div className="max-w-4xl w-full">
                <div className="text-center mb-6">
                  <div className="flex items-center justify-center gap-4">
                    <h1 className="text-5xl font-bold text-white drop-shadow-lg">aespa TETRIS</h1>
                    <button
                      onClick={toggleMute}
                      className="bg-black/50 hover:bg-black/70 text-white p-2 rounded-lg transition"
                      title={isMuted ? "Unmute" : "Mute"}
                    >
                      {isMuted ? <VolumeMuteIcon /> : <VolumeIcon />}
                    </button>
                    {gameStarted && !gameOver && (
                      <button
                        onClick={togglePause}
                        className="bg-black/50 hover:bg-black/70 text-white p-2 rounded-lg transition"
                        title={isPaused ? "Resume (P)" : "Pause (P)"}
                      >
                        {isPaused ? <PlayIconSmall /> : <PauseIcon />}
                      </button>
                    )}
                  </div>
                  <p className="text-sm text-pink-300 mt-2">by @kwon88im</p>
                  {!allImagesPreloaded && (
                    <p className="text-xs text-yellow-300 mt-1">Loading images...</p>
                  )}
                </div>
                
                <div className="flex flex-col md:flex-row gap-6 justify-center items-start">
                  <div className="bg-black/50 p-6 rounded-lg backdrop-blur relative">
                    <div 
                      className="grid gap-0 border-4 border-pink-500 shadow-2xl"
                      style={{
                        gridTemplateColumns: `repeat(${BOARD_WIDTH}, ${BLOCK_SIZE}px)`,
                        gridTemplateRows: `repeat(${BOARD_HEIGHT}, ${BLOCK_SIZE}px)`
                      }}
                      onTouchStart={onTouchStart}
                      onTouchMove={onTouchMove}
                      onTouchEnd={onTouchEnd}
                    >
                      {getDisplayBoard().map((row, y) =>
                        row.map((cell, x) => (
                          <div key={`${y}-${x}`} style={{ width: BLOCK_SIZE, height: BLOCK_SIZE }}>
                            {renderCell(cell)}
                          </div>
                        ))
                      )}
                    </div>

                    {isPaused && (
                      <div className="absolute inset-0 flex items-center justify-center bg-black/80 rounded-lg">
                        <div className="text-center">
                          <h2 className="text-4xl font-bold text-white mb-4">PAUSED</h2>
                          <p className="text-pink-300 text-sm">Press P or ESC to resume</p>
                          <button
                            onClick={togglePause}
                            className="mt-4 bg-gradient-to-r from-pink-500 to-purple-500 hover:from-pink-600 hover:to-purple-600 text-white font-bold py-2 px-6 rounded-lg transition"
                          >
                            Resume
                          </button>
                        </div>
                      </div>
                    )}

                    {gameStarted && !gameOver && !isPaused && (
                      <div className="mt-4 flex flex-col gap-2 md:hidden">
                        <div className="flex justify-center gap-2">
                          <button 
                            onTouchStart={handleRotateTouch}
                            onTouchEnd={(e) => e.preventDefault()}
                            onClick={rotate}
                            className="bg-purple-500 active:bg-purple-700 text-white font-bold py-4 px-8 rounded-lg flex items-center justify-center transition select-none"
                            style={{ WebkitTapHighlightColor: 'transparent' }}
                          >
                            <RotateCw size={28} />
                          </button>
                        </div>
                        <div className="flex justify-center gap-2">
                          <button 
                            onTouchStart={handleButtonTouch(moveLeft)}
                            onTouchEnd={(e) => e.preventDefault()}
                            onClick={moveLeft}
                            className="bg-blue-500 active:bg-blue-700 text-white font-bold py-4 px-10 rounded-lg text-2xl transition select-none"
                            style={{ WebkitTapHighlightColor: 'transparent' }}
                          >
                            ‚Üê
                          </button>
                          <button 
                            onTouchStart={handleButtonTouch(moveDown)}
                            onTouchEnd={(e) => e.preventDefault()}
                            onClick={moveDown}
                            className="bg-blue-500 active:bg-blue-700 text-white font-bold py-4 px-10 rounded-lg text-2xl transition select-none"
                            style={{ WebkitTapHighlightColor: 'transparent' }}
                          >
                            ‚Üì
                          </button>
                          <button 
                            onTouchStart={handleButtonTouch(moveRight)}
                            onTouchEnd={(e) => e.preventDefault()}
                            onClick={moveRight}
                            className="bg-blue-500 active:bg-blue-700 text-white font-bold py-4 px-10 rounded-lg text-2xl transition select-none"
                            style={{ WebkitTapHighlightColor: 'transparent' }}
                          >
                            ‚Üí
                          </button>
                        </div>
                      </div>
                    )}
                  </div>

                  <div className="bg-black/50 backdrop-blur rounded-lg p-6 space-y-4 min-w-[200px]">
                    <div className="text-white space-y-2">
                      <div className="text-2xl font-bold">Score: {score}</div>
                      <div className="text-xl">Level: {level}</div>
                    </div>

                    {!gameStarted && (
                      <button onClick={initGame} className="w-full bg-gradient-to-r from-pink-500 to-purple-500 hover:from-pink-600 hover:to-purple-600 text-white font-bold py-3 px-6 rounded-lg flex items-center justify-center gap-2 transition">
                        <Play />
                        Start Game
                      </button>
                    )}

                    {gameOver && (
                      <div className="text-center">
                        <div className="text-red-500 font-bold text-xl mb-3">Game Over!</div>
                        <button onClick={initGame} className="w-full bg-gradient-to-r from-pink-500 to-purple-500 hover:from-pink-600 hover:to-purple-600 text-white font-bold py-3 px-6 rounded-lg flex items-center justify-center gap-2 transition">
                          <Play />
                          Play Again
                        </button>
                      </div>
                    )}

                    <div className="border-t border-gray-600 pt-4 text-white space-y-2">
                      <div className="font-bold text-lg mb-2">Controls:</div>
                      <div className="text-sm space-y-1">
                        <div className="hidden md:block">‚Üê ‚Üí Move</div>
                        <div className="hidden md:block">‚Üì Drop faster</div>
                        <div className="hidden md:block">‚Üë / Space: Rotate</div>
                        <div className="hidden md:block">P / ESC: Pause</div>
                        <div className="md:hidden">Swipe to move</div>
                        <div className="md:hidden">You can now pause and resume, button is available!</div>
                        <div className="text-xs text-pink-300 mt-2">üéµ Music plays during game</div>
                      </div>
                    </div>

                    <div className="border-t border-gray-600 pt-4 space-y-2">
                      <div className="text-white font-bold text-sm mb-2">Members:</div>
                      <div className="text-xs text-gray-300 mb-2">Each member has 6 different pictures!</div>
                      {AESPA_MEMBERS.map(member => (
                        <div key={member.name} className="flex items-center gap-2">
                          <div className={`w-6 h-6 ${member.color} border-2 ${member.border} rounded`}></div>
                          <span className="text-white text-sm">{member.name}</span>
                        </div>
                      ))}
                      
                      <button
                        onClick={() => setShowLeaderboard(true)}
                        className="w-full mt-4 bg-gradient-to-r from-yellow-500 to-orange-500 hover:from-yellow-600 hover:to-orange-600 text-white font-bold py-3 px-6 rounded-lg flex items-center justify-center gap-2 transition"
                      >
                        <TrophyIcon />
                        Personal Leaderboard
                      </button>
                    </div>
                  </div>
                </div>

                <div className="mt-6 text-center">
                  <div className="bg-black/30 backdrop-blur rounded-lg p-4 inline-block">
                    <div className="text-white text-sm space-y-1">
                      <div className="font-bold">Created by:</div>
                      <a href="https://twitter.com/kwon88im" target="_blank" rel="noopener noreferrer" className="text-blue-400 hover:text-blue-300 transition block">
                        @KWON88IM
                      </a>
                      <div className="text-gray-400 text-xs mt-2">Music by Walen - Gameboy</div>
                      <div className="text-gray-400 text-xs mt-2">Version 1.3.0 (Personal Scores)</div>
                    </div>
                  </div>
                </div>

                {/* High Score Entry Modal */}
                {showHighScoreEntry && (
                  <div className="fixed inset-0 bg-black/80 flex items-center justify-center z-50 p-4">
                    <div className="bg-gradient-to-br from-purple-900 to-pink-900 rounded-lg p-8 max-w-md w-full border-4 border-pink-500">
                      <h2 className="text-4xl font-bold text-white text-center mb-4">
                        {isHighScore(finalGameScore) ? 'üéâ NEW HIGH SCORE! üéâ' : 'Game Over!'}
                      </h2>
                      <p className="text-2xl text-pink-300 text-center mb-2">Score: {finalGameScore}</p>
                      {isHighScore(finalGameScore) ? (
                        <p className="text-sm text-yellow-300 text-center mb-2">You made it to your Top 10!</p>
                      ) : (
                        <p className="text-sm text-gray-300 text-center mb-2">Save your score to track your progress</p>
                      )}
                      <div className="bg-blue-900/50 border border-blue-400 rounded-lg p-3 mb-4">
                        <p className="text-xs text-blue-200 text-center">
                          ‚ÑπÔ∏è Scores are saved locally on your device only. This is your personal record!
                        </p>
                      </div>
                      <input
                        type="text"
                        placeholder="Enter your name"
                        value={playerName}
                        onChange={(e) => setPlayerName(e.target.value)}
                        maxLength={20}
                        className="w-full bg-black/50 text-white border-2 border-pink-500 rounded-lg px-4 py-3 mb-4 text-center text-xl"
                        onKeyPress={(e) => {
                          if (e.key === 'Enter') {
                            saveScoreToLeaderboard(playerName, finalGameScore);
                          }
                        }}
                        autoFocus
                      />
                      <div className="flex gap-2">
                        <button
                          onClick={() => saveScoreToLeaderboard(playerName, finalGameScore)}
                          className="flex-1 bg-gradient-to-r from-pink-500 to-purple-500 hover:from-pink-600 hover:to-purple-600 text-white font-bold py-3 px-6 rounded-lg transition"
                        >
                          Save Score
                        </button>
                        <button
                          onClick={() => setShowHighScoreEntry(false)}
                          className="flex-1 bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-6 rounded-lg transition"
                        >
                          Skip
                        </button>
                      </div>
                    </div>
                  </div>
                )}

                {/* Leaderboard Modal */}
                {showLeaderboard && (
                  <div className="fixed inset-0 bg-black/80 flex items-center justify-center z-50 p-4">
                    <div className="bg-gradient-to-br from-purple-900 to-pink-900 rounded-lg p-8 max-w-md w-full border-4 border-pink-500 max-h-[90vh] overflow-y-auto">
                      <div className="flex items-center justify-center mb-4">
                        <TrophyIcon />
                        <h2 className="text-3xl font-bold text-white ml-2">LEADERBOARD</h2>
                      </div>
                      
                      <div className="bg-blue-900/50 border border-blue-400 rounded-lg p-2 mb-4">
                        <p className="text-xs text-blue-200 text-center">
                          üìä Your Personal Top 10 Scores (Saved on this device only)
                        </p>
                      </div>
                      
                      {leaderboard.length === 0 ? (
                        <p className="text-white text-center py-8">No scores yet. Play to set your first record!</p>
                      ) : (
                        <div className="space-y-2">
                          {leaderboard.map((entry, index) => (
                            <div
                              key={index}
                              className={`flex items-center justify-between p-3 rounded-lg ${
                                index === 0 ? 'bg-yellow-500/30 border-2 border-yellow-500' :
                                index === 1 ? 'bg-gray-400/30 border-2 border-gray-400' :
                                index === 2 ? 'bg-orange-600/30 border-2 border-orange-600' :
                                'bg-black/30'
                              }`}
                            >
                              <div className="flex items-center gap-3">
                                <span className="text-2xl font-bold text-white w-8">
                                  {index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `${index + 1}.`}
                                </span>
                                <div>
                                  <div className="text-white font-bold">{entry.name}</div>
                                  <div className="text-pink-300 text-xs">
                                    {new Date(entry.date).toLocaleDateString()}
                                  </div>
                                </div>
                              </div>
                              <div className="text-2xl font-bold text-white">{entry.score}</div>
                            </div>
                          ))}
                        </div>
                      )}
                      
                      <button
                        onClick={() => setShowLeaderboard(false)}
                        className="w-full mt-6 bg-gradient-to-r from-pink-500 to-purple-500 hover:from-pink-600 hover:to-purple-600 text-white font-bold py-3 px-6 rounded-lg transition"
                      >
                        Close
                      </button>
                    </div>
                  </div>
                )}
              </div>
            </div>
          );
        };

        ReactDOM.render(<AespaTetris />, document.getElementById('root'));
    </script>
</body>
</html>
